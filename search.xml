<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>reading 10.08</title>
      <link href="/2021/10/08/daily-reading-1008/"/>
      <url>/2021/10/08/daily-reading-1008/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Remember,you can always find light in the dark.</p></blockquote><h4 id="1-如何将字符串反转？"><a href="#1-如何将字符串反转？" class="headerlink" title="1. 如何将字符串反转？"></a>1. 如何将字符串反转？</h4><p>将对象封装到stringBuilder中，调用reverse方法反转。</p><hr><h4 id="2-new-String-“a”-new-String-“b”-会创建几个对象？"><a href="#2-new-String-“a”-new-String-“b”-会创建几个对象？" class="headerlink" title="2. new String(“a”) + new String(“b”)会创建几个对象？"></a>2. new String(“a”) + new String(“b”)会创建几个对象？</h4><p>对象1： new StringBuilder()</p><p>对象2：new String(“a”)</p><p>对象3：常量池中的”a”</p><p>对象4：new String(“b”)</p><p>对象5：常量池中的”b”</p><p>深入剖析：StringBuilder中的toString():</p><p>对象6：new String(“ab”)</p><p>强调，toString()的调用，在字符串常量池中，没有生成”ab”。</p><hr><h4 id="3-String-类的常用方法有哪些？"><a href="#3-String-类的常用方法有哪些？" class="headerlink" title="3. String 类的常用方法有哪些？"></a>3. String 类的常用方法有哪些？</h4><p>equals、length、contains、replace、split、hashcode、indexof、substring、trim、toUpperCase、toLowerCase、isEmpty等。</p>]]></content>
      
      
      
        <tags>
            
            <tag> daily-reading </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>reading 10.07</title>
      <link href="/2021/10/07/daily-reading-1007/"/>
      <url>/2021/10/07/daily-reading-1007/</url>
      
        <content type="html"><![CDATA[<blockquote><p>I’m willing to fight for those who cannot for themselves.</p></blockquote><h4 id="1-Java中的Math-round-1-5-等于多少？"><a href="#1-Java中的Math-round-1-5-等于多少？" class="headerlink" title="1. Java中的Math.round(-1.5)等于多少？"></a>1. Java中的Math.round(-1.5)等于多少？</h4><p>Math提供了三个与取整有关的方法：ceil、floor、round</p><p>ceil: 向上取整；floor: 向下取整; round:  四舍五入（加0.5然后乡下取整）</p><p>所以结果等于-2</p><hr><h4 id="2-String-属于基础的数据类型吗？"><a href="#2-String-属于基础的数据类型吗？" class="headerlink" title="2. String 属于基础的数据类型吗？"></a>2. String 属于基础的数据类型吗？</h4><p>不属于。</p><p>八种基本数据类型： byte、short、char、int、long、double、float、boolean。</p><hr><h4 id="3-String-str-“i”-与String-str-new-String-“i”-一样吗？"><a href="#3-String-str-“i”-与String-str-new-String-“i”-一样吗？" class="headerlink" title="3. String str = “i” 与String str = new String(“i”)一样吗？"></a>3. String str = “i” 与String str = new String(“i”)一样吗？</h4><p>String str= “i”会将其分配到常量池中，如果常量池中存在，就将i的地址赋给变量，如果没有就创建一个再赋给变量。</p><p>String str= new String(“i” )会将对象分配到堆中，即使内存一样，还是会重新创建一个新的对象。</p>]]></content>
      
      
      
        <tags>
            
            <tag> daily-reading </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>reading 10.06</title>
      <link href="/2021/10/06/daily-reading-1006/"/>
      <url>/2021/10/06/daily-reading-1006/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Even miracles take a little time.</p></blockquote><h4 id="1-JDK-和-JRE-有什么区别？"><a href="#1-JDK-和-JRE-有什么区别？" class="headerlink" title="1. JDK 和 JRE 有什么区别？"></a>1. JDK 和 JRE 有什么区别？</h4><p>JDK（Java Development Kit）  Java开发工具</p><p>JRE （Java Runtime Environment） Java运行环境</p><p>JDK中包含JRE，JDK8前有一个名为jre的目录，里面包含两个文件夹bin和lib</p><p>bin就是JVM，lib就是JVM工作所需要的类库</p><hr><h4 id="2-和-equals-的区别是什么？"><a href="#2-和-equals-的区别是什么？" class="headerlink" title="2. == 和 equals 的区别是什么？"></a>2. == 和 equals 的区别是什么？</h4><p>对于基本类型， ==比较的是值；</p><p>对于引用类型， ==比较的是地址；</p><p>equals不能用于基本类型的比较；</p><p>如果没有重写equals， equals就相当于==；</p><p>如果重写了equals方法，equals比较得是对象的内容；</p><hr><h4 id="3-final在-Java-中有什么作用？"><a href="#3-final在-Java-中有什么作用？" class="headerlink" title="3. final在 Java 中有什么作用？"></a>3. final在 Java 中有什么作用？</h4><p>-final修饰的成员变量，必须在生命的同时赋值，一旦创建不可修改；</p><p>-final修饰的方法，不能被子类重写；</p><p>-final类中的方法默认是final的；</p><p>-private类型的方法默认是final的；</p>]]></content>
      
      
      
        <tags>
            
            <tag> daily-reading </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven 自定义 archetype</title>
      <link href="/2021/10/06/archetype/"/>
      <url>/2021/10/06/archetype/</url>
      
        <content type="html"><![CDATA[<h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><blockquote><p>由于项目开发过程中，大多数开发人员遵循的模板不一致，都是从别的项目中copy过来的。有时候项目出现了一个大bug，经过排查可能发现是工具类用错了，容易踩坑；另外，每次新建项目重复创建类似的结构也很是浪费时间。</p></blockquote><p> 基于以上情况，有必要进行<strong>工程脚手架建设</strong>。<font color="red">重要</font>﻿</p><p>﻿</p><h2 id="二、方案"><a href="#二、方案" class="headerlink" title="二、方案"></a>二、方案</h2><ul><li><p>方案一：使用纯脚本的方式，在 project 目录下创建需要的模板文件</p></li><li><p>方案二：使用 mvn archetype 插件</p><p>这里我们采用方案二</p></li></ul><h2 id="三、自定义archetype步骤"><a href="#三、自定义archetype步骤" class="headerlink" title="三、自定义archetype步骤"></a>三、自定义archetype步骤</h2><h3 id="1-说明"><a href="#1-说明" class="headerlink" title="1. 说明"></a>1. 说明</h3><p>​     环境版本说明</p><ul><li>openjdk  “11.0.12”</li><li>IntelliJ IDEA 2021.2.2 (Ultimate Edition)</li><li>Maven 3.8.2</li></ul><h3 id="2-本地Maven配置"><a href="#2-本地Maven配置" class="headerlink" title="2. 本地Maven配置"></a>2. 本地Maven配置</h3><p>Maven-&gt;conf-&gt;settings.xml配置如下，这里仅指定了本地仓库路径和阿里云Maven镜像</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>/Users/mqxu/tools/maven_jar<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyunmaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>阿里云公共仓库<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/central<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-创建模板项目"><a href="#3-创建模板项目" class="headerlink" title="3. 创建模板项目"></a>3. 创建模板项目</h3><p>正常创建Maven项目，完成需要的配置即可，正确运行即可。</p><p>我们就以现在的java-jfx项目为例，依赖、结构已经就绪，还自定义了标题栏。</p><p>我们希望把它做成一个模版，以后可以直接基于它来创建 javafx相关的项目。</p><h3 id="4-从当前项目创建archetype"><a href="#4-从当前项目创建archetype" class="headerlink" title="4. 从当前项目创建archetype"></a>4. 从当前项目创建archetype</h3><p>在项目根目录（和pom.xml文件同级）执行下面的语句﻿</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:create-from-project </span><br></pre></td></tr></table></figure><p>应该会报错</p><p><img src="https://cdn.jsdelivr.net/gh/shiyouhan/image/1004-1.png"></p><p><strong>解决方法:</strong> </p><p><strong>把maven目录conf中的settings.xml文件，复制到你电脑当前用户目录的隐藏目录 .m2 中</strong></p><p><img src="https://cdn.jsdelivr.net/gh/shiyouhan/image/1004-2.png"></p><p>  maven clean一下， 重新运行上一步的命令，即可构建成功，并在target目录生成了如图所示的文件</p><p><img src="https://cdn.jsdelivr.net/gh/shiyouhan/image/1004-3.png"></p><h3 id="5-生成并发布archetype"><a href="#5-生成并发布archetype" class="headerlink" title="5. 生成并发布archetype"></a>5. 生成并发布archetype</h3><p><strong>在项目根目录，依次执行以下命令</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> target/generated-sources/archetype   <span class="comment"># 进入模版目录</span></span><br><span class="line">mvn install         <span class="comment"># 安装到本地仓库</span></span><br><span class="line">mvn archetype:crawl <span class="comment"># 在本地仓库生成 archetype 配置文件</span></span><br></pre></td></tr></table></figure><p>执行成功后，在本地仓库的根目录会生成archetype-catalog.xml骨架配置文件，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/shiyouhan/image/1004-4.png"></p><p>打开该文件内容如下，可以看到我们的项目骨架已经生成</p><p><img src="https://cdn.jsdelivr.net/gh/shiyouhan/image/1004-5.png"></p><blockquote><p>至此，模板项目已经创建完成。</p></blockquote><h2 id="四、使用模板"><a href="#四、使用模板" class="headerlink" title="四、使用模板"></a>四、使用模板</h2><blockquote><p>在需要创建项目的地方启动终端，执行下面的命令（local表示从本地读取骨架项目模版，如果从网络读取maven提供的模版，会比较多）</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate -DarchetypeCatalog=<span class="built_in">local</span></span><br></pre></td></tr></table></figure><p>按照图中步骤操作即可</p><p><img src="https://cdn.jsdelivr.net/gh/shiyouhan/image/1004-6.png"></p><p>在IDEA中打开新项目</p><p><img src="https://cdn.jsdelivr.net/gh/shiyouhan/image/1004-7.png"></p><p>注意：如果要在上面窗口配置git，点击红色那行，点笔的图标，修改目录为当前的项目。因为之前的git配置，git仓库是java-jfx的父级目录JavaStudy，所以这里也默认把我项目的父级目录Desktop作为默认仓库地址了。</p><p>maven刷新完成后，仔细检查一下新项目的pom、module-info、fxml等相关文件</p><p><img src="https://cdn.jsdelivr.net/gh/shiyouhan/image/1004-8.png"></p><p>这些需要修改为新的</p><p><img src="https://cdn.jsdelivr.net/gh/shiyouhan/image/1004-9.png"></p><blockquote><p> 随便改改图片颜色就是一个新项目啦，脚手架有没有很好用？</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/shiyouhan/image/1004-10.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> maven </tag>
            
            <tag> javafx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java继承和多态</title>
      <link href="/2021/09/19/java%E7%BB%A7%E6%89%BF/"/>
      <url>/2021/09/19/java%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。</p><p>继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p><hr><h6 id="类的继承格式："><a href="#类的继承格式：" class="headerlink" title="类的继承格式："></a>类的继承格式：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 父类 </span>&#123;...&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> 子类 <span class="keyword">extends</span> 父类 </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><hr><h6 id="为什么需要继承？"><a href="#为什么需要继承？" class="headerlink" title="为什么需要继承？"></a>为什么需要继承？</h6><p>代码存在重复，导致后果就是代码量大且臃肿，而且维护性不高(维护性主要是后期需要修改的时候，就需要修改很多的代码，容易出错)，所以要从根本上解决这两段代码的问题，就需要继承，将两段代码中相同的部分提取出来组成 一个父类。</p><hr><h6 id="继承类型："><a href="#继承类型：" class="headerlink" title="继承类型："></a><strong>继承类型：</strong></h6><ul><li><p>单一继承</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure></li><li><p>多重继承</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure></li><li><p>不同类继承同一个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure></li><li><p><font color=red>不支持多继承</font>（extends）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span>,<span class="title">B</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>继承关键字</strong></p><ol><li><p><strong>extends</strong> (单一继承)</p><p>只能继承一个类，也就是说，一个子类只能拥有一个父类</p></li><li><p><strong>implements</strong>(多继承)</p><p>可以同时继承多个接口（接口跟接口之间采用逗号分隔）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">A</span>,<span class="title">B</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>final</strong></p><ul><li>声明类可以把类定义为不能继承</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><ul><li>用于修饰方法，该方法不能被子类重写</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> 返回值类型 方法名() &#123;...&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>super</strong></p><p>访问直接父类中被隐藏的数据成员</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">super</span>.数据成员</span><br></pre></td></tr></table></figure><p>调用直接父类中被重写的成员方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">super</span>.成员方法([参数列表])</span><br></pre></td></tr></table></figure><p>调用直接父类的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">super</span>([参数列表]</span><br></pre></td></tr></table></figure></li><li><p><strong>this</strong></p><p>访问当前对象的数据成员</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.数据成员</span><br></pre></td></tr></table></figure><p>访问当前对象的成员方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.成员方法([参数列表])</span><br></pre></td></tr></table></figure><p>当有重载的构造方法时，用于引用同类的其他构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>([参数列表]</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态是同一个行为具有多个不同表现形式或形态的能力。</p><p>多态就是同一个接口，使用不同的实例而执行不同操作。</p><h6 id="多态的必要条件："><a href="#多态的必要条件：" class="headerlink" title="多态的必要条件："></a>多态的必要条件：</h6><ul><li>继承</li><li>重写</li><li>父类引用子类对象</li></ul><hr><h3 id="重写-override"><a href="#重写-override" class="headerlink" title="重写(override)"></a>重写(override)</h3><p>重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。也就是说子类能够根据需要实现父类的方法。<font color = red>外壳不变，核心重写！</font></p><p>下面举例说明:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;人在走路&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;儿童在奔跑&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Override</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      Person p = <span class="keyword">new</span> Person(); <span class="comment">// Person 对象</span></span><br><span class="line">      Person c = <span class="keyword">new</span> Child(); <span class="comment">// Child 对象</span></span><br><span class="line"> </span><br><span class="line">      p.walk();<span class="comment">// 执行 Person 类的方法</span></span><br><span class="line"> </span><br><span class="line">      c.walk();<span class="comment">// 执行 Child 类的方法</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">人在走路</span><br><span class="line">儿童在奔跑</span><br></pre></td></tr></table></figure><hr><p>使用super关键字进行重写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;人在走路&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">super</span>.walk();  <span class="comment">//super类的方法(上面关键字super有提到)</span></span><br><span class="line">      System.out.println(<span class="string">&quot;儿童在奔跑&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Override</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      Person c = <span class="keyword">new</span> Child(); <span class="comment">// Child 对象</span></span><br><span class="line">      c.walk();<span class="comment">// 执行 Child 类的方法</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">人在走路</span><br><span class="line">儿童在奔跑</span><br></pre></td></tr></table></figure><hr><h3 id="重载-overload"><a href="#重载-overload" class="headerlink" title="重载(overload)"></a>重载(overload)</h3><p>重载是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。</p><p>每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</p><p>下面举例说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Overload</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(<span class="keyword">int</span> a,String s)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test3&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;returntest3&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(String s,<span class="keyword">int</span> a)</span></span>&#123;  <span class="comment">//参数类型顺序不同亦为不同</span></span><br><span class="line">        System.out.println(<span class="string">&quot;test4&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;returntest4&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Overload o = <span class="keyword">new</span> Overload();</span><br><span class="line">        System.out.println(o.test());</span><br><span class="line">        o.test(<span class="number">1</span>);</span><br><span class="line">        System.out.println(o.test(<span class="number">1</span>,<span class="string">&quot;test3&quot;</span>));</span><br><span class="line">        System.out.println(o.test(<span class="string">&quot;test4&quot;</span>,<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">test1</span><br><span class="line">1</span><br><span class="line">test2</span><br><span class="line">test3</span><br><span class="line">returntest3</span><br><span class="line">test4</span><br><span class="line">returntest4</span><br></pre></td></tr></table></figure><hr><table><thead><tr><th>区别</th><th>参数列表</th><th>返回类型</th><th>异常</th><th>访问</th></tr></thead><tbody><tr><td>重写</td><td>一定不能修改</td><td>一定不能修改</td><td>可以减少或删除</td><td>一定不能做更严格的限制</td></tr><tr><td>重载</td><td>必须修改</td><td>可以修改</td><td>可以修改</td><td>可以修改</td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/shiyouhan/image/%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>about java</title>
      <link href="/2021/09/17/java/"/>
      <url>/2021/09/17/java/</url>
      
        <content type="html"><![CDATA[<h6 id="特点如下："><a href="#特点如下：" class="headerlink" title="特点如下："></a>特点如下：</h6><ul><li><font color="red">面向对象</font><ol><li><strong>封装</strong> 把过程和数据包围起来，对数据的访问只能通过已定义的接口。</li><li><strong>继承</strong> 使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。</li><li><strong>多态</strong> 允许将子类类型的指针赋值给父类类型的指针。</li></ol></li><li><em><font color = "red">强类型</font></em><ol><li><strong>java.net</strong> 这个包提供了网络、套接字处理器和 Internet 实用工具类。</li><li><strong>java.sql</strong> 这个包提供了结构化查询语言数据库字段类型和方法的实现。根据系统的不同，这个包的类可能会通过一个特定的数据库系统实现，或者缺省时通过 ODBC(开放数据库连接)标准的直接映射实现。</li><li><strong>java.io</strong> 这个包中的类提供了输入输出服务，用于读出和写入文件数据，访问键盘输入和打印输出。</li></ol></li></ul><p>首先谈谈面向对象，关于类和对象，这个一定要有深刻的认识，在类中，首先一个最重要的概念就是构造方法，为什么说它重要，就是因为你只要需要创建一个类地实例对象就需要调用到构造方法，这个就决定了这个类一开始要做什么。</p><p>接下来要看的就是具体类地方法，这个直接说明了它能操作什么，有什么功能，在方法中返回值也很重要，这时不得不提到 java 的强类型，真因为这样，你必须要了解一个方法具体的返回值，是对象还是那种数据类型，这样你才好定义容器或者相应的类来接收这个返回值，才好进行接下来的操作。</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>about me</title>
      <link href="/2021/09/17/about/"/>
      <url>/2021/09/17/about/</url>
      
        <content type="html"><![CDATA[<center>     <h1>菜鸟小施</h1>     <div>         <span>             <img src="https://niit-soft.oss-cn-hangzhou.aliyuncs.com/assets/phone-solid.svg" width="20px">             180****4983         </span>         ·         <span>             <img src="https://niit-soft.oss-cn-hangzhou.aliyuncs.com/assets/envelope-solid.svg" width="20px">             2470752581@qq.com         </span>         ·         <span>             <img src="https://cdn.jsdelivr.net/gh/shiyouhan/image/头像.jpg" width="20px">             <a href="https://github.com/shiyouhan">Syhan的Github</a>         </span>         ·         <span>             <img src="https://cdn.jsdelivr.net/gh/shiyouhan/image/头像.jpg" width="20px">             <a href="https://hexo.syhan.top">Syhan的博客</a>         </span>     </div> </center><h2 id="个人信息"><a href="#个人信息" class="headerlink" title=" 个人信息"></a><img src="https://niit-soft.oss-cn-hangzhou.aliyuncs.com/assets/info-circle-solid.svg" width="30px"> 个人信息</h2><ul><li>在校大学生</li></ul><h2 id="技能清单"><a href="#技能清单" class="headerlink" title=" 技能清单"></a><img src="https://niit-soft.oss-cn-hangzhou.aliyuncs.com/assets/tools-solid.svg" width="30px"> 技能清单</h2><ul><li>★★☆ Java</li><li>★★☆ HTML/CSS/JavaScript</li><li>★★☆ C++</li><li>★★☆ MySQL</li><li>★★☆ Linux</li><li>★☆☆ Python</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Syhan </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
