<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>daily-reading-1018</title>
      <link href="/2021/10/19/daily-reading-1018/"/>
      <url>/2021/10/19/daily-reading-1018/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>reading 10.17</title>
      <link href="/2021/10/18/daily-reading-1017/"/>
      <url>/2021/10/18/daily-reading-1017/</url>
      
        <content type="html"><![CDATA[<h4 id="Java-9-新特性"><a href="#Java-9-新特性" class="headerlink" title="Java 9 新特性"></a>Java 9 新特性</h4><p>Java 正式发布于2017年9月21日。作为 Java8 之后3年半才发布的新版本，</p><p>Java9 带来了很多重大的变化。其中最重要的改动是Java平台模块系统的引入。</p><p><img src="https://raw.githubusercontent.com/shiyouhan/image/main/java9.png?token=AVS2VSVHKQC2ETPD5C6HH6TBNUOUO"></p>]]></content>
      
      
      
        <tags>
            
            <tag> daily-reading </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>reading 10.16</title>
      <link href="/2021/10/16/daily-reading-1016/"/>
      <url>/2021/10/16/daily-reading-1016/</url>
      
        <content type="html"><![CDATA[<blockquote><p>The answer must be in the attempt.</p></blockquote><h4 id="Java-8-特性"><a href="#Java-8-特性" class="headerlink" title="Java 8 特性"></a>Java 8 特性</h4><ul><li><p>接口的默认方法（Default Methods for Interfaces）</p></li><li><p>Lambda表达式（Lambda expressions）</p></li><li><p>函数式接口（Functional Interfaces）</p></li><li><p>方法和构造函数的引用（Method and Constructor References）</p></li><li><p>Lambda 表达式作用域（Lambda Scopes）</p><ul><li>访问局部变量</li><li>访问字段和静态变量</li><li>访问默认接口方法</li></ul></li><li><p>内置函数式接口（Built-in Functional Interfaces）</p><ul><li>Predicates</li><li>Functions</li><li>Suppliers</li><li>Consumers</li><li>Comparators</li></ul></li><li><p>Optionals</p></li><li><p>Streams(流)</p><ul><li>Filter(过滤)</li><li>Sorted(排序)</li><li>Map(映射)</li><li>Match(匹配)</li><li>Count(计数)</li><li>Reduce(规约)</li></ul></li><li><p>Parallel Streams(并行流)</p><ul><li>Sequential Sort(串行排序)</li><li>Parallel Sort(并行排序)</li></ul></li><li><p>Maps</p></li><li><p>Data API(日期相关API)</p><ul><li>Clock</li><li>Timezones(时区)</li><li>LocalTime(本地时间)</li><li>LocalDate(本地日期)</li><li>LocalDateTime(本地日期时间)</li></ul></li><li><p>Annotations(注释)</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> daily-reading </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>reading 10.15</title>
      <link href="/2021/10/15/daily-reading-1015/"/>
      <url>/2021/10/15/daily-reading-1015/</url>
      
        <content type="html"><![CDATA[<blockquote><p>The man who embraces the dark is never without sight.</p></blockquote><h4 id="1-Java为什么不允许从静态方法中访问非静态变量？"><a href="#1-Java为什么不允许从静态方法中访问非静态变量？" class="headerlink" title="1. Java为什么不允许从静态方法中访问非静态变量？"></a>1. Java为什么不允许从静态方法中访问非静态变量？</h4><p>1.静态变量属于类本身，在类加载的时候就会分配内存，可以通过类名直接访问；</p><p>2.非静态变量属于类的对象，只有在类的对象产生时，才会分配内存，通过类的实例去访问；</p><p>3.静态方法也属于类本身，但是此时没有类的实例，内存中没有非静态变量，所以无法调用。</p><hr><h4 id="2-在-Java-中，什么时候用重载，什么时候用重写？"><a href="#2-在-Java-中，什么时候用重载，什么时候用重写？" class="headerlink" title="2. 在 Java 中，什么时候用重载，什么时候用重写？"></a>2. 在 Java 中，什么时候用重载，什么时候用重写？</h4><p>（1）重载是多态的集体体现，在类中，要以统一的方式处理不同类型数据的时候，可以用重载。</p><p>（2）重写的使用是建立在继承关系上的，子类在继承父类的基础上，增加新的功能，可以用重写。</p><p>（3）简单总结：</p><p>重载是多样性，重写是增强剂；</p><p>如果目的是提高程序的多样性和健壮性，以适配不同场景使用时，使用重载进行扩展；</p><p>如果目的是在不修改的原方法及源代码的基础上对方法进行扩展或增强时，使用重写；</p>]]></content>
      
      
      
        <tags>
            
            <tag> daily-reading </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>reading 10.14</title>
      <link href="/2021/10/14/daily-reading-1014/"/>
      <url>/2021/10/14/daily-reading-1014/</url>
      
        <content type="html"><![CDATA[<blockquote><p>You took the sourest lemon that life has to offer and turned it into something resembling lemonade.</p></blockquote><h4 id="1-为什么要使用克隆？如何实现对象克隆？"><a href="#1-为什么要使用克隆？如何实现对象克隆？" class="headerlink" title="1. 为什么要使用克隆？如何实现对象克隆？"></a>1. 为什么要使用克隆？如何实现对象克隆？</h4><p>（1）什么要使用克隆？</p><p>想对一个对象进行复制，又想保留原有的对象进行接下来的操作，此时就需要克隆。</p><p>（2）如何实现对象克隆？</p><p>实现Cloneable接口，重写clone方法；</p><p>实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深克隆。BeanUtils, apache和Spring 都提供了bean工具，只是这些都是浅克隆。</p><hr><h4 id="2-深拷贝和浅拷贝区别是什么？"><a href="#2-深拷贝和浅拷贝区别是什么？" class="headerlink" title="2. 深拷贝和浅拷贝区别是什么？"></a>2. 深拷贝和浅拷贝区别是什么？</h4><p>浅拷贝：仅仅克隆基本类型变量，不克隆引用类型变量；</p><p>深克隆：既克隆基本类型变量，又克隆引用类型变量；</p>]]></content>
      
      
      
        <tags>
            
            <tag> daily-reading </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>reading 10.13</title>
      <link href="/2021/10/13/daily-reading-1013/"/>
      <url>/2021/10/13/daily-reading-1013/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Money is not life’s report card.</p></blockquote><h4 id="Java-中都有哪些引用类型？"><a href="#Java-中都有哪些引用类型？" class="headerlink" title="Java 中都有哪些引用类型？"></a>Java 中都有哪些引用类型？</h4><p>（1）强引用（StrongReference）</p><p>Java中默认申明的就是强引用，比如：</p><p><code>Object obj = new Object();</code></p><p><code> obj  =  null;</code></p><p>只要强引用存在，垃圾回收器将永远不会回收被引用的对象。如果想被回收，可以将对象置为null;</p><p>（2）软引用（SoftReference）</p><p>在内存足够的时候，软应用不会被回收，只有在内存不足时，系统才会收回软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会内存溢出异常。</p><p><code>byte[] buff = new byte[1024 * 1024];</code></p><p><code>SoftReference&lt;byte[]&gt; sr = new SoftReference&lt;&gt;(buff);</code></p><p>（3）弱引用（WeakReference）</p><p>进行垃圾回收时，弱引用就会被回收。</p><p>（4）虚引用（PhantomReference）</p><p>（5）引用队列（ReferenceQueue）</p><p>引用队列可以与软引用、弱引用、虚引用一起配合使用。当垃圾回收器准备回收一个对象是，如果发现它还有引用，就会在回收对象之前，把这个引用加入到引用队列中。程序可以通过判断引用队列中是否加入了引用，来判断被引用的对象是否将要被垃圾回收，这样可以在对象被回收之前采取一些必要的措施。</p>]]></content>
      
      
      
        <tags>
            
            <tag> daily-reading </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>reading 10.12</title>
      <link href="/2021/10/12/daily-reading-1012/"/>
      <url>/2021/10/12/daily-reading-1012/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Power resides where men beileve it resides.</p></blockquote><h4 id="1-Java-中操作字符串都有哪些类？他们之间有什么区别？"><a href="#1-Java-中操作字符串都有哪些类？他们之间有什么区别？" class="headerlink" title="1. Java 中操作字符串都有哪些类？他们之间有什么区别？"></a>1. Java 中操作字符串都有哪些类？他们之间有什么区别？</h4><p>（1）String</p><p>String是不可变对象，每次对String类型的改变时都会生成一个新的对象。</p><p>（2）StringBuilder</p><p>线程不安全，效率高，多用于单线程</p><p>（3）StringBuffer</p><p>线程安全，由于加锁的原因，效率不如StringBuilder,多用于多线程；</p><p>不频繁的字符串操使用String，操作频繁的情况不建议使用String。</p><p>StringBuilder &gt; StringBuffer &gt; String</p><hr><h4 id="2-在Java中，为什么不允许静态方法中访问非静态变量？"><a href="#2-在Java中，为什么不允许静态方法中访问非静态变量？" class="headerlink" title="2. 在Java中，为什么不允许静态方法中访问非静态变量？"></a>2. 在Java中，为什么不允许静态方法中访问非静态变量？</h4><ol><li>静态变量属于类本身，在类加载的时候就会分配内存，可以通过类名直接访问；</li><li> 非静态变量属于类的对象，只有在类的对象产生是，才会分配内存，通过类的实例去访问；</li><li>静态方法也属于类本身，但是此时没有类的实例，内存中没有非静态变量，所以无法使用。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> daily-reading </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>reading 10.11</title>
      <link href="/2021/10/11/daily-reading-1011/"/>
      <url>/2021/10/11/daily-reading-1011/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Nothing can help us endure dark times better than our faith.</p></blockquote><h4 id="1-什么是-Java-序列化？-什么情况下需要序列化？"><a href="#1-什么是-Java-序列化？-什么情况下需要序列化？" class="headerlink" title="1. 什么是 Java 序列化？ 什么情况下需要序列化？"></a>1. 什么是 Java 序列化？ 什么情况下需要序列化？</h4><p><strong>序列化就是一种用来处理对象流的机制。将对象的内容流化，将流化后的对象传输于网络之间。</strong></p><p>序列化是通过实现Serializable接口，该接口没有需要实现的方法，实现该接口只是为了标注该对象是可被序列化的，使用一个输出流（FileOutputStream）来构造一个ObjectOutputStream对象，接着使用ObjectOutStream对象的writeObject(Object object)方法就可以将参数的obj对象到磁盘，需要恢复的时间使用输入流。</p><p><strong>序列化是将对象转换为容易传输的格式的过程。</strong></p><p>例如，可以序列化一个对象，然后通过HTTP通过Internet在客户端和服务器之间传输该对象。在另一端，反序列化将从流中心构造成对象。</p><p>程序在运行时产生对象，这些对象随着程序的停止而消失，但我们想讲某些对象保存下来，这时，我们就可以通过序列化讲对象保存在磁盘，需要使用的时候通过反序列化获取到。</p><p><strong>对象序列化的最主要的目的就是传递和保存对象，保存对象的完整性和可传递性。</strong></p><p>譬如通过网络传输或者是把一个对象保存成本地一个文件的时候，需要使用序列化。</p>]]></content>
      
      
      
        <tags>
            
            <tag> daily-reading </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>reading 10.10</title>
      <link href="/2021/10/10/daliy-reading-1010/"/>
      <url>/2021/10/10/daliy-reading-1010/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Always let your conscience be your guide.</p></blockquote><h4 id="1-Java-中IO-流分为几种？"><a href="#1-Java-中IO-流分为几种？" class="headerlink" title="1. Java 中IO 流分为几种？"></a>1. Java 中IO 流分为几种？</h4><p>（1）桉流划分，可以分为输入流和输出流；</p><p>（2）按单位划分，可以分为字节流和字符流；</p><p>字节流：InputStream、OutputStream;</p><p>字符流：Reader、Writer;</p><hr><h4 id="2-BIO、NIO、AIO有什么区别？"><a href="#2-BIO、NIO、AIO有什么区别？" class="headerlink" title="2. BIO、NIO、AIO有什么区别？"></a>2. BIO、NIO、AIO有什么区别？</h4><p>（1）同步阻塞BIO：一个连接一个线程。</p><p>（2）同步非阻塞NIO：一个请求一个线程。</p><p>（3）异步非阻塞AIO：一个有效请求一个线程。</p><hr><h4 id="3-什么是反射？"><a href="#3-什么是反射？" class="headerlink" title="3. 什么是反射？"></a>3. 什么是反射？</h4><p>所谓反射，是Java在运行中进行自我观察的能力，通过class、constructor、field、method四个方法获取一个类的各种组成部分。</p><p>在Java运行时环境中，对任何一个类，可以知道类有哪些属性和方法。这种动态获取类的信息以及动态调用对象的方法的功能来自反射机制。</p>]]></content>
      
      
      
        <tags>
            
            <tag> daily-reading </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>reading 10.09</title>
      <link href="/2021/10/09/daily-reading-1009/"/>
      <url>/2021/10/09/daily-reading-1009/</url>
      
        <content type="html"><![CDATA[<blockquote><p>If you focus on what you left behind, you will never be able to see what lies ahead.</p></blockquote><h4 id="1-普通类和抽象类有哪些区别？"><a href="#1-普通类和抽象类有哪些区别？" class="headerlink" title="1. 普通类和抽象类有哪些区别？"></a>1. 普通类和抽象类有哪些区别？</h4><p>抽象类不能被实例化；抽象类可以有抽象方法，只需申明，无需实现；</p><p>有抽象方法的类一定是抽象类；抽象类的子类必须实现抽象类中的所有抽象方法，</p><p>否则子类仍然是抽象类；抽象方法不能申明为静态、不能被static、final修饰。</p><h4 id="2-接口和抽象类有什么区别？"><a href="#2-接口和抽象类有什么区别？" class="headerlink" title="2.接口和抽象类有什么区别？"></a>2.接口和抽象类有什么区别？</h4><p>（1）接口</p><p>接口使用interface修饰；接口不能实例化；类可以实现多个接口；</p><p>Java8之前，接口中的方法都是抽象方法，省略了public abstract；</p><p>Java8之后，接口中可以定义静态方法，静态方法必须有方法体，普通方法没有方法体，需要被实现；</p><p>（2）抽象类</p><p>抽象类使用abstract修饰；抽象类不能被实例化；抽象类只能单继承；</p><p>抽象类中可以包含抽象方法和非抽象方法，非抽象方法需要有方法体；</p><p>如果一个类继承了抽象类：</p><p>-如果实现了所有的抽象方法，子类可以不是抽象类；</p><p>-如果没有实现所有的抽象方法，子类仍然是抽象类；</p>]]></content>
      
      
      
        <tags>
            
            <tag> daily-reading </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>reading 10.08</title>
      <link href="/2021/10/08/daily-reading-1008/"/>
      <url>/2021/10/08/daily-reading-1008/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Remember,you can always find light in the dark.</p></blockquote><h4 id="1-如何将字符串反转？"><a href="#1-如何将字符串反转？" class="headerlink" title="1. 如何将字符串反转？"></a>1. 如何将字符串反转？</h4><p>将对象封装到stringBuilder中，调用reverse方法反转。</p><hr><h4 id="2-new-String-“a”-new-String-“b”-会创建几个对象？"><a href="#2-new-String-“a”-new-String-“b”-会创建几个对象？" class="headerlink" title="2. new String(“a”) + new String(“b”)会创建几个对象？"></a>2. new String(“a”) + new String(“b”)会创建几个对象？</h4><p>对象1： new StringBuilder()</p><p>对象2：new String(“a”)</p><p>对象3：常量池中的”a”</p><p>对象4：new String(“b”)</p><p>对象5：常量池中的”b”</p><p>深入剖析：StringBuilder中的toString():</p><p>对象6：new String(“ab”)</p><p>强调，toString()的调用，在字符串常量池中，没有生成”ab”。</p><hr><h4 id="3-String-类的常用方法有哪些？"><a href="#3-String-类的常用方法有哪些？" class="headerlink" title="3. String 类的常用方法有哪些？"></a>3. String 类的常用方法有哪些？</h4><p>equals、length、contains、replace、split、hashcode、indexof、substring、trim、toUpperCase、toLowerCase、isEmpty等。</p>]]></content>
      
      
      
        <tags>
            
            <tag> daily-reading </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>reading 10.07</title>
      <link href="/2021/10/07/daily-reading-1007/"/>
      <url>/2021/10/07/daily-reading-1007/</url>
      
        <content type="html"><![CDATA[<blockquote><p>I’m willing to fight for those who cannot for themselves.</p></blockquote><h4 id="1-Java中的Math-round-1-5-等于多少？"><a href="#1-Java中的Math-round-1-5-等于多少？" class="headerlink" title="1. Java中的Math.round(-1.5)等于多少？"></a>1. Java中的Math.round(-1.5)等于多少？</h4><p>Math提供了三个与取整有关的方法：ceil、floor、round</p><p>ceil: 向上取整；floor: 向下取整; round:  四舍五入（加0.5然后乡下取整）</p><p>所以结果等于-2</p><hr><h4 id="2-String-属于基础的数据类型吗？"><a href="#2-String-属于基础的数据类型吗？" class="headerlink" title="2. String 属于基础的数据类型吗？"></a>2. String 属于基础的数据类型吗？</h4><p>不属于。</p><p>八种基本数据类型： byte、short、char、int、long、double、float、boolean。</p><hr><h4 id="3-String-str-“i”-与String-str-new-String-“i”-一样吗？"><a href="#3-String-str-“i”-与String-str-new-String-“i”-一样吗？" class="headerlink" title="3. String str = “i” 与String str = new String(“i”)一样吗？"></a>3. String str = “i” 与String str = new String(“i”)一样吗？</h4><p>String str= “i”会将其分配到常量池中，如果常量池中存在，就将i的地址赋给变量，如果没有就创建一个再赋给变量。</p><p>String str= new String(“i” )会将对象分配到堆中，即使内存一样，还是会重新创建一个新的对象。</p>]]></content>
      
      
      
        <tags>
            
            <tag> daily-reading </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>reading 10.06</title>
      <link href="/2021/10/06/daily-reading-1006/"/>
      <url>/2021/10/06/daily-reading-1006/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Even miracles take a little time.</p></blockquote><h4 id="1-JDK-和-JRE-有什么区别？"><a href="#1-JDK-和-JRE-有什么区别？" class="headerlink" title="1. JDK 和 JRE 有什么区别？"></a>1. JDK 和 JRE 有什么区别？</h4><p>JDK（Java Development Kit）  Java开发工具</p><p>JRE （Java Runtime Environment） Java运行环境</p><p>JDK中包含JRE，JDK8前有一个名为jre的目录，里面包含两个文件夹bin和lib</p><p>bin就是JVM，lib就是JVM工作所需要的类库</p><hr><h4 id="2-和-equals-的区别是什么？"><a href="#2-和-equals-的区别是什么？" class="headerlink" title="2. == 和 equals 的区别是什么？"></a>2. == 和 equals 的区别是什么？</h4><p>对于基本类型， ==比较的是值；</p><p>对于引用类型， ==比较的是地址；</p><p>equals不能用于基本类型的比较；</p><p>如果没有重写equals， equals就相当于==；</p><p>如果重写了equals方法，equals比较得是对象的内容；</p><hr><h4 id="3-final在-Java-中有什么作用？"><a href="#3-final在-Java-中有什么作用？" class="headerlink" title="3. final在 Java 中有什么作用？"></a>3. final在 Java 中有什么作用？</h4><p>-final修饰的成员变量，必须在生命的同时赋值，一旦创建不可修改；</p><p>-final修饰的方法，不能被子类重写；</p><p>-final类中的方法默认是final的；</p><p>-private类型的方法默认是final的；</p>]]></content>
      
      
      
        <tags>
            
            <tag> daily-reading </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven 自定义 archetype</title>
      <link href="/2021/10/06/archetype/"/>
      <url>/2021/10/06/archetype/</url>
      
        <content type="html"><![CDATA[<h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><blockquote><p>由于项目开发过程中，大多数开发人员遵循的模板不一致，都是从别的项目中copy过来的。有时候项目出现了一个大bug，经过排查可能发现是工具类用错了，容易踩坑；另外，每次新建项目重复创建类似的结构也很是浪费时间。</p></blockquote><p> 基于以上情况，有必要进行<strong>工程脚手架建设</strong>。<font color="red">重要</font>﻿</p><p>﻿</p><h2 id="二、方案"><a href="#二、方案" class="headerlink" title="二、方案"></a>二、方案</h2><ul><li><p>方案一：使用纯脚本的方式，在 project 目录下创建需要的模板文件</p></li><li><p>方案二：使用 mvn archetype 插件</p><p>这里我们采用方案二</p></li></ul><h2 id="三、自定义archetype步骤"><a href="#三、自定义archetype步骤" class="headerlink" title="三、自定义archetype步骤"></a>三、自定义archetype步骤</h2><h3 id="1-说明"><a href="#1-说明" class="headerlink" title="1. 说明"></a>1. 说明</h3><p>​     环境版本说明</p><ul><li>openjdk  “11.0.12”</li><li>IntelliJ IDEA 2021.2.2 (Ultimate Edition)</li><li>Maven 3.8.2</li></ul><h3 id="2-本地Maven配置"><a href="#2-本地Maven配置" class="headerlink" title="2. 本地Maven配置"></a>2. 本地Maven配置</h3><p>Maven-&gt;conf-&gt;settings.xml配置如下，这里仅指定了本地仓库路径和阿里云Maven镜像</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>/Users/mqxu/tools/maven_jar<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyunmaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>阿里云公共仓库<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/central<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-创建模板项目"><a href="#3-创建模板项目" class="headerlink" title="3. 创建模板项目"></a>3. 创建模板项目</h3><p>正常创建Maven项目，完成需要的配置即可，正确运行即可。</p><p>我们就以现在的java-jfx项目为例，依赖、结构已经就绪，还自定义了标题栏。</p><p>我们希望把它做成一个模版，以后可以直接基于它来创建 javafx相关的项目。</p><h3 id="4-从当前项目创建archetype"><a href="#4-从当前项目创建archetype" class="headerlink" title="4. 从当前项目创建archetype"></a>4. 从当前项目创建archetype</h3><p>在项目根目录（和pom.xml文件同级）执行下面的语句﻿</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:create-from-project </span><br></pre></td></tr></table></figure><p>应该会报错</p><p><img src="https://cdn.jsdelivr.net/gh/shiyouhan/image/1004-1.png"></p><p><strong>解决方法:</strong> </p><p><strong>把maven目录conf中的settings.xml文件，复制到你电脑当前用户目录的隐藏目录 .m2 中</strong></p><p><img src="https://cdn.jsdelivr.net/gh/shiyouhan/image/1004-2.png"></p><p>  maven clean一下， 重新运行上一步的命令，即可构建成功，并在target目录生成了如图所示的文件</p><p><img src="https://cdn.jsdelivr.net/gh/shiyouhan/image/1004-3.png"></p><h3 id="5-生成并发布archetype"><a href="#5-生成并发布archetype" class="headerlink" title="5. 生成并发布archetype"></a>5. 生成并发布archetype</h3><p><strong>在项目根目录，依次执行以下命令</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> target/generated-sources/archetype   <span class="comment"># 进入模版目录</span></span><br><span class="line">mvn install         <span class="comment"># 安装到本地仓库</span></span><br><span class="line">mvn archetype:crawl <span class="comment"># 在本地仓库生成 archetype 配置文件</span></span><br></pre></td></tr></table></figure><p>执行成功后，在本地仓库的根目录会生成archetype-catalog.xml骨架配置文件，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/shiyouhan/image/1004-4.png"></p><p>打开该文件内容如下，可以看到我们的项目骨架已经生成</p><p><img src="https://cdn.jsdelivr.net/gh/shiyouhan/image/1004-5.png"></p><blockquote><p>至此，模板项目已经创建完成。</p></blockquote><h2 id="四、使用模板"><a href="#四、使用模板" class="headerlink" title="四、使用模板"></a>四、使用模板</h2><blockquote><p>在需要创建项目的地方启动终端，执行下面的命令（local表示从本地读取骨架项目模版，如果从网络读取maven提供的模版，会比较多）</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate -DarchetypeCatalog=<span class="built_in">local</span></span><br></pre></td></tr></table></figure><p>按照图中步骤操作即可</p><p><img src="https://cdn.jsdelivr.net/gh/shiyouhan/image/1004-6.png"></p><p>在IDEA中打开新项目</p><p><img src="https://cdn.jsdelivr.net/gh/shiyouhan/image/1004-7.png"></p><p>注意：如果要在上面窗口配置git，点击红色那行，点笔的图标，修改目录为当前的项目。因为之前的git配置，git仓库是java-jfx的父级目录JavaStudy，所以这里也默认把我项目的父级目录Desktop作为默认仓库地址了。</p><p>maven刷新完成后，仔细检查一下新项目的pom、module-info、fxml等相关文件</p><p><img src="https://cdn.jsdelivr.net/gh/shiyouhan/image/1004-8.png"></p><p>这些需要修改为新的</p><p><img src="https://cdn.jsdelivr.net/gh/shiyouhan/image/1004-9.png"></p><blockquote><p> 随便改改图片颜色就是一个新项目啦，脚手架有没有很好用？</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/shiyouhan/image/1004-10.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> maven </tag>
            
            <tag> javafx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java继承和多态</title>
      <link href="/2021/09/19/java%E7%BB%A7%E6%89%BF/"/>
      <url>/2021/09/19/java%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。</p><p>继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p><hr><h6 id="类的继承格式："><a href="#类的继承格式：" class="headerlink" title="类的继承格式："></a>类的继承格式：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 父类 </span>&#123;...&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> 子类 <span class="keyword">extends</span> 父类 </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><hr><h6 id="为什么需要继承？"><a href="#为什么需要继承？" class="headerlink" title="为什么需要继承？"></a>为什么需要继承？</h6><p>代码存在重复，导致后果就是代码量大且臃肿，而且维护性不高(维护性主要是后期需要修改的时候，就需要修改很多的代码，容易出错)，所以要从根本上解决这两段代码的问题，就需要继承，将两段代码中相同的部分提取出来组成 一个父类。</p><hr><h6 id="继承类型："><a href="#继承类型：" class="headerlink" title="继承类型："></a><strong>继承类型：</strong></h6><ul><li><p>单一继承</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure></li><li><p>多重继承</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure></li><li><p>不同类继承同一个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure></li><li><p><font color=red>不支持多继承</font>（extends）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span>,<span class="title">B</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>继承关键字</strong></p><ol><li><p><strong>extends</strong> (单一继承)</p><p>只能继承一个类，也就是说，一个子类只能拥有一个父类</p></li><li><p><strong>implements</strong>(多继承)</p><p>可以同时继承多个接口（接口跟接口之间采用逗号分隔）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">A</span>,<span class="title">B</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>final</strong></p><ul><li>声明类可以把类定义为不能继承</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><ul><li>用于修饰方法，该方法不能被子类重写</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> 返回值类型 方法名() &#123;...&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>super</strong></p><p>访问直接父类中被隐藏的数据成员</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">super</span>.数据成员</span><br></pre></td></tr></table></figure><p>调用直接父类中被重写的成员方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">super</span>.成员方法([参数列表])</span><br></pre></td></tr></table></figure><p>调用直接父类的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">super</span>([参数列表]</span><br></pre></td></tr></table></figure></li><li><p><strong>this</strong></p><p>访问当前对象的数据成员</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.数据成员</span><br></pre></td></tr></table></figure><p>访问当前对象的成员方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.成员方法([参数列表])</span><br></pre></td></tr></table></figure><p>当有重载的构造方法时，用于引用同类的其他构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>([参数列表]</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态是同一个行为具有多个不同表现形式或形态的能力。</p><p>多态就是同一个接口，使用不同的实例而执行不同操作。</p><h6 id="多态的必要条件："><a href="#多态的必要条件：" class="headerlink" title="多态的必要条件："></a>多态的必要条件：</h6><ul><li>继承</li><li>重写</li><li>父类引用子类对象</li></ul><hr><h3 id="重写-override"><a href="#重写-override" class="headerlink" title="重写(override)"></a>重写(override)</h3><p>重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。也就是说子类能够根据需要实现父类的方法。<font color = red>外壳不变，核心重写！</font></p><p>下面举例说明:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;人在走路&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;儿童在奔跑&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Override</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      Person p = <span class="keyword">new</span> Person(); <span class="comment">// Person 对象</span></span><br><span class="line">      Person c = <span class="keyword">new</span> Child(); <span class="comment">// Child 对象</span></span><br><span class="line"> </span><br><span class="line">      p.walk();<span class="comment">// 执行 Person 类的方法</span></span><br><span class="line"> </span><br><span class="line">      c.walk();<span class="comment">// 执行 Child 类的方法</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">人在走路</span><br><span class="line">儿童在奔跑</span><br></pre></td></tr></table></figure><hr><p>使用super关键字进行重写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;人在走路&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">super</span>.walk();  <span class="comment">//super类的方法(上面关键字super有提到)</span></span><br><span class="line">      System.out.println(<span class="string">&quot;儿童在奔跑&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Override</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      Person c = <span class="keyword">new</span> Child(); <span class="comment">// Child 对象</span></span><br><span class="line">      c.walk();<span class="comment">// 执行 Child 类的方法</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">人在走路</span><br><span class="line">儿童在奔跑</span><br></pre></td></tr></table></figure><hr><h3 id="重载-overload"><a href="#重载-overload" class="headerlink" title="重载(overload)"></a>重载(overload)</h3><p>重载是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。</p><p>每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</p><p>下面举例说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Overload</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(<span class="keyword">int</span> a,String s)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test3&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;returntest3&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(String s,<span class="keyword">int</span> a)</span></span>&#123;  <span class="comment">//参数类型顺序不同亦为不同</span></span><br><span class="line">        System.out.println(<span class="string">&quot;test4&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;returntest4&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Overload o = <span class="keyword">new</span> Overload();</span><br><span class="line">        System.out.println(o.test());</span><br><span class="line">        o.test(<span class="number">1</span>);</span><br><span class="line">        System.out.println(o.test(<span class="number">1</span>,<span class="string">&quot;test3&quot;</span>));</span><br><span class="line">        System.out.println(o.test(<span class="string">&quot;test4&quot;</span>,<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">test1</span><br><span class="line">1</span><br><span class="line">test2</span><br><span class="line">test3</span><br><span class="line">returntest3</span><br><span class="line">test4</span><br><span class="line">returntest4</span><br></pre></td></tr></table></figure><hr><table><thead><tr><th>区别</th><th>参数列表</th><th>返回类型</th><th>异常</th><th>访问</th></tr></thead><tbody><tr><td>重写</td><td>一定不能修改</td><td>一定不能修改</td><td>可以减少或删除</td><td>一定不能做更严格的限制</td></tr><tr><td>重载</td><td>必须修改</td><td>可以修改</td><td>可以修改</td><td>可以修改</td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/shiyouhan/image/%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>about java</title>
      <link href="/2021/09/17/java/"/>
      <url>/2021/09/17/java/</url>
      
        <content type="html"><![CDATA[<h6 id="特点如下："><a href="#特点如下：" class="headerlink" title="特点如下："></a>特点如下：</h6><ul><li><font color="red">面向对象</font><ol><li><strong>封装</strong> 把过程和数据包围起来，对数据的访问只能通过已定义的接口。</li><li><strong>继承</strong> 使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。</li><li><strong>多态</strong> 允许将子类类型的指针赋值给父类类型的指针。</li></ol></li><li><em><font color = "red">强类型</font></em><ol><li><strong>java.net</strong> 这个包提供了网络、套接字处理器和 Internet 实用工具类。</li><li><strong>java.sql</strong> 这个包提供了结构化查询语言数据库字段类型和方法的实现。根据系统的不同，这个包的类可能会通过一个特定的数据库系统实现，或者缺省时通过 ODBC(开放数据库连接)标准的直接映射实现。</li><li><strong>java.io</strong> 这个包中的类提供了输入输出服务，用于读出和写入文件数据，访问键盘输入和打印输出。</li></ol></li></ul><p>首先谈谈面向对象，关于类和对象，这个一定要有深刻的认识，在类中，首先一个最重要的概念就是构造方法，为什么说它重要，就是因为你只要需要创建一个类地实例对象就需要调用到构造方法，这个就决定了这个类一开始要做什么。</p><p>接下来要看的就是具体类地方法，这个直接说明了它能操作什么，有什么功能，在方法中返回值也很重要，这时不得不提到 java 的强类型，真因为这样，你必须要了解一个方法具体的返回值，是对象还是那种数据类型，这样你才好定义容器或者相应的类来接收这个返回值，才好进行接下来的操作。</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>about me</title>
      <link href="/2021/09/17/about/"/>
      <url>/2021/09/17/about/</url>
      
        <content type="html"><![CDATA[<center>     <h1>菜鸟小施</h1>     <div>         <span>             <img src="https://niit-soft.oss-cn-hangzhou.aliyuncs.com/assets/phone-solid.svg" width="20px">             180****4983         </span>         ·         <span>             <img src="https://niit-soft.oss-cn-hangzhou.aliyuncs.com/assets/envelope-solid.svg" width="20px">             2470752581@qq.com         </span>         ·         <span>             <img src="https://cdn.jsdelivr.net/gh/shiyouhan/image/头像.jpg" width="20px">             <a href="https://github.com/shiyouhan">Syhan的Github</a>         </span>         ·         <span>             <img src="https://cdn.jsdelivr.net/gh/shiyouhan/image/头像.jpg" width="20px">             <a href="https://hexo.syhan.top">Syhan的博客</a>         </span>     </div> </center><h2 id="个人信息"><a href="#个人信息" class="headerlink" title=" 个人信息"></a><img src="https://niit-soft.oss-cn-hangzhou.aliyuncs.com/assets/info-circle-solid.svg" width="30px"> 个人信息</h2><ul><li>在校大学生</li></ul><h2 id="技能清单"><a href="#技能清单" class="headerlink" title=" 技能清单"></a><img src="https://niit-soft.oss-cn-hangzhou.aliyuncs.com/assets/tools-solid.svg" width="30px"> 技能清单</h2><ul><li>★★☆ Java</li><li>★★☆ HTML/CSS/JavaScript</li><li>★★☆ C++</li><li>★★☆ MySQL</li><li>★★☆ Linux</li><li>★☆☆ Python</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Syhan </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
